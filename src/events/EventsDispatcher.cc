
# include "EventsDispatcher.hh"
# include <core_utils/CoreWrapper.hh>
# include "KeyEvent.hh"
# include "QuitEvent.hh"

namespace sdl {
  namespace core {
    namespace engine {

      EventsDispatcher::EventsDispatcher(const float& eventHandlingRate,
                                         EngineShPtr engine,
                                         const bool exitOnEscape,
                                         const std::string& name):
        utils::CoreObject(name),
        EventsQueue(),
        m_framerate(std::max(0.1f, eventHandlingRate)),
        m_frameDuration(1000.0f / m_framerate),
        m_exitOnEscape(exitOnEscape),

        m_engine(engine),

        m_eventsRunning(false),
        m_executionLocker(),
        m_executionThread(nullptr),

        m_eventsLocker(),
        m_directedEvents(),
        m_spontaneousEvents(),

        m_listeners(),
        m_listenersLocker()
      {
        setService("events");

        if (m_engine == nullptr) {
          error(std::string("Cannot create event handler with null engine"));
        }
      }

      EventsDispatcher::~EventsDispatcher() {
        stop();
      }

      void
      EventsDispatcher::fetchSystemEvents() {
        // Start the event handling.
        m_executionLocker.lock();
        m_eventsRunning = true;
        m_executionLocker.unlock();

        bool stillRunning = true;
        while (stillRunning) {
          stillRunning = isRunning();

          if (!stillRunning) {
            break;
          }

          // Fetch system events.
          int osEventsDuration = consumeSystemEvents();

          // Process events in queue.
          int allEventsDuration = dispatchEventsFromQueue();

          int processingDuration = osEventsDuration + allEventsDuration;

          // Check whether the rendering time is compatible with the desired framerate.
          if (1.0f * processingDuration > m_frameDuration) {
            // Log this problem.
            log(
              std::string("Event handling took ") + std::to_string(processingDuration) + "ms " +
              "which is greater than the " + std::to_string(m_frameDuration) + "ms " +
              " authorized to maintain " + std::to_string(m_framerate) + "fps",
              utils::Level::Warning
            );

            // Move on to the next frame.
            continue;
          }

          // Sleep for the remaining time to complete a frame if there's enough time left.
          const unsigned int remainingDuration = m_frameDuration - processingDuration;
          if (remainingDuration > 3u) {
            std::this_thread::sleep_for(std::chrono::milliseconds(remainingDuration));
          }
        }

        log(std::string("Exiting events thread"), utils::Level::Notice);
      }

      int
      EventsDispatcher::consumeSystemEvents() {
        // Poll events until we deplete the queue.
        bool eventsStillInQueue = true;

        // Start time measurement.
        auto start = std::chrono::steady_clock::now();

        while (eventsStillInQueue) {
          EventShPtr event = m_engine->pollEvent(eventsStillInQueue);

          // Enqueue this event if it is relevant.
          if (eventsStillInQueue && event != nullptr && event->getType() != Event::Type::None) {
            postEvent(event);
          }
        }

        // Return the elapsed time.
        return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start).count();
      }

      int
      EventsDispatcher::dispatchEventsFromQueue() {
        // Start time measurement.
        auto start = std::chrono::steady_clock::now();

        // The dispatch of events from queue is divided into two
        // separate parts:
        // 1) Handling spontaneous events
        // 2) Handling directed events.
        // Each phase is important but both are not treated exactly
        // in the same way.
        // Indeed most of the `spontaneous` events are in fact
        // generated by the system while most of the `directed` events
        // are produced by UI elements.
        // It is not uncommon for the processing of a `directed` event
        // to generate more (`directed`) events while it is quite rare
        // for `spontaneous` to do so.
        // Considering this, we choose to process `directed` events
        // until no more are added (which could take forever) while
        // we only process the `spontaneous` registered at the time of
        // calling this method and none of the potentially newly
        // generated.

        // First handle `spontaneous` events.
        dispatchSpontaneousEvents();

        // Now handle the `directed` events. We need to keep looping
        // until no more events are registered. This includes processing
        // newly generated ones.
        std::pair<Event::Type, EventsShPtr> events;

        do {
          // Retrieve the queue into an internal variable so
          // that we can release the lock and allow components
          // to post new events.
          {
            // Clear previously processed events if any.
            if (events.second != nullptr) {
              events.second->clear();
            }

            // Try to retrieve the first 
            std::lock_guard<std::mutex> guard(m_eventsLocker);

            if (!m_directedEvents.empty()) {

              events.swap(m_directedEvents[0]);
              m_directedEvents.erase(m_directedEvents.begin());
            }
          }

          // Now that events are sorted, we can dispatch each type.
          // We discard `None` events right away.
          if (events.first != Event::Type::None) {
            // Dispatch the events of this type.
            if (events.second != nullptr) {
              withSafetyNet(
                [&events, this]() {
                  dispatchEvents(*events.second);
                },
                std::string("dispatchEvent")
              );
            }
          }

          // Loop until no more events are fetched from the `directed` pool.
        } while (events.second != nullptr && !events.second->empty());

        // Return the elapsed time.
        return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - start).count();
      }

      void
      EventsDispatcher::dispatchSpontaneousEvents() {
        // Handle the events registered in the spontaneous queue. This function
        // is basically a loop on all the sponatenous registered in the internal
        // queue to send each one of them to the registered listeners.
        // In order not to block the events' queue more than needed, we first
        // copy the internal data of `m_spontaneousEvents` into a local variable
        // and then iterate on it.
        // In addition to allowing the system to still produce events while we're
        // processing some (even though we should ideally aim at controlling this
        // fact not to be drown in events), it also has the double advantage to
        // allow listeners to react the events by posting some more events.

        // Copy the events to process into a local variable.
        Events spontaneous;

        {
          std::lock_guard<std::mutex> guard(m_eventsLocker);
          spontaneous.swap(m_spontaneousEvents);
        }

        // Process each event.
        for (Events::const_iterator event = spontaneous.cbegin() ;
             event != spontaneous.cend() ;
             ++event)
        {
          // Event with type `None` are discarded right away.
          if ((*event)->getType() != Event::Type::None) {
              withSafetyNet(
                [&event, this]() {
                  dispatchEvent(*event);
                },
                std::string("dispatchEvent")
              );
          }
        }
      }

      void
      EventsDispatcher::dispatchEvents(const Events& events) {
        // Iterate over the input array of events and dispatch each one of them.
        for (Events::const_iterator event = events.cbegin() ;
             event != events.cend() ;
             ++event)
        {
          dispatchEvent(*event);
        }
      }

      void
      EventsDispatcher::dispatchEvent(const EventShPtr event) {
        // Transmit the input `event` and dispatch it to all registered listeners.
        // We only have one special case which is when the `Escape` key is pressed
        // and the internal `m_exitOnEscape` status is ticked: in this case we want
        // to bypass the regular event processing and allow the creation of a quit
        // event and process it as usual.

        // Check for key released.
        if (event->getType() == Event::Type::KeyRelease) {
          // Check the key which was pressed.
          std::shared_ptr<KeyEvent> keyEvent = std::dynamic_pointer_cast<KeyEvent>(event);

          // If the conversion was successful and that it corresponds to the `Escape`
          // key, we need to check the internal status to determine the next action.
          if (keyEvent != nullptr && keyEvent->isEscape() && m_exitOnEscape) {
            // Replace the input event with a quit event.
            dispatchEvent(std::make_shared<QuitEvent>());

            // All is well.
            return;
          }

          // Continue to standard processing.
        }

        // Transmit the event to all listeners or to only the receiver if the event
        // is spontaneous.
        if (!event->isSpontaneous()) {
          // Dispatch the event to the receiver.
          log("Dispatching " + Event::getNameFromEvent(event) + " for " + event->getReceiver()->getName());
          event->getReceiver()->event(event);
          return;
        }

        // The event is not spontaneous, transmit it to all listeners.
        // log("Dispatching " + Event::getNameFromEvent(event));
        for (std::vector<EngineObject*>::iterator listener = m_listeners.begin() ;
            listener != m_listeners.end() ;
            ++listener)
        {
          (*listener)->event(event);
        }
      }

      void
      EventsDispatcher::sortEventsByType(AllEvents& events) {
        // Sorting events focues on assigning some kind of priority
        // to the directed events.
        // We only handle some events which we know are considered
        // prioritary in the sense that they can generate some other
        // types of events.
        // For example a `resize` event triggers a `geometry update`.
        // So from the queue perspective it makes sense to process
        // the `resize` event first so the `geometry update` which
        // will be generated get a chance to override any existing
        // instance of such an event.
        // We rely on the sort algorithm provided by the standard
        // library with our custom comparison operator.
        // In order to easily process events 

        // Among all the possible events types, we set the following
        // precedence:
        // None               Not defined
        // Enter              3
        // FocusIn            5
        // FocusOut           6
        // GeometryUpdate     2
        // KeyPress           Not defined
        // KeyRelease         Not defined
        // Leave              4
        // MouseButtonPress   Not defined
        // MouseButtonRelease Not defined
        // MouseMove          Not defined
        // MouseWheel         Not defined
        // Refresh            Not defined
        // Repaint            7
        // Resize             1
        // WindowEnter        Not defined
        // WindowLeave        Not defined
        // WindowResize       Not defined
        // Quit               Not defined
        // Not that if a type has no associated number it means that
        // it is not compared (and thus set equal to all other non
        // defined types).

        auto getID = [](const Event::Type& type) {
          switch (type) {
            case Event::Type::Resize:
              return 1;
            case Event::Type::GeometryUpdate:
              return 2;
            case Event::Type::Enter:
              return 3;
            case Event::Type::Leave:
              return 4;
            case Event::Type::FocusIn:
              return 5;
            case Event::Type::FocusOut:
              return 6;
            case Event::Type::Repaint:
              return 7;
            default:
              return 8;
          }
        };

        std::sort(
          events.begin(),
          events.end(),
          [&getID](const std::pair<Event::Type, EventsShPtr>& lhs,
             const std::pair<Event::Type, EventsShPtr>& rhs)
          {
            return getID(lhs.first) < getID(rhs.first);
          }
        );
      }

      void
      EventsDispatcher::trimAndPostSpontaneousEvent(EventShPtr e) {
        // No particular control is performed for spontaneous event. These events
        // are supposed to be generated by the OS and thus we assume a filtering
        // already takes place to keep only relevant events and drop the rest.
        log("Broadcasting " + Event::getNameFromEvent(e));
        m_spontaneousEvents.push_back(e);
      }

      void
      EventsDispatcher::trimAndPostDirectedEvent(EventShPtr e) {
        // We need to check whether a similar event already exists with the same
        // receiver and the same data already exists.
        // If this is the case, we can drop this event as it would result in a
        // duplicated processing.

        // Traverse the directed events queue and check for existing elements.
        bool duplicated = false;

        AllEvents::const_iterator existingType = m_directedEvents.cbegin();
        while (!duplicated && existingType != m_directedEvents.cend()) {
          // Check whether this type corresponds to the type of the input event.
          if (existingType->first != e->getType()) {
            ++existingType;
          }
          else {
            // Traverse the list of events existing for this type and try to find one corresponding
            // to the input one.
            Events::iterator event = existingType->second->begin();
            while (!duplicated && event != existingType->second->end()) {
              duplicated = ((**event) == *e);
              if (!duplicated) {
                ++event;
              }
            }

            // Check whether this event is duplicated.
            if (duplicated) {
              // Erase with the new event if it is more recent.
              if ((*event)->getTimestamp() < e->getTimestamp()) {
                log("Dropping " + Event::getNameFromEvent(e) + " for " + e->getReceiver()->getName());
                return;
              }
              event->swap(e);
            }
            else {
              // Move on to the next type.
              ++existingType;
            }
          }
        }

        // Queue the event. We need to account for the fact that we either did not found any
        // event matching the input one even though some events already existed for this type
        // or that there's no events for this type at all.
        log("Queuing " + Event::getNameFromEvent(e) + " for " + e->getReceiver()->getName());

        // Check whether no events of this type already exist.
        if (existingType == m_directedEvents.cend()) {
          m_directedEvents.push_back(
            std::make_pair(e->getType(), std::make_shared<Events>(1u, e))
          );
        }
        else {
          existingType->second->push_back(e);
        }

        // Sort these events so that we process the most basic ones
        // first: this allows not to waste some processing time to
        // handle a cycle like so:
        // repaint -> geometry -> repaint (generated).
        // The order in the input `events` array is only chronological
        // with no consideration about the real meaning of events.
        // This queue can make sense of such events and thus speed up
        // the processing.
        sortEventsByType(m_directedEvents);
      }

    }
  }
}
