#ifndef    EVENTS_DISPATCHER_HH
# define   EVENTS_DISPATCHER_HH

# include <memory>
# include <vector>
# include <thread>
# include <mutex>
# include <core_utils/CoreObject.hh>
# include "Engine.hh"
# include "EngineObject.hh"
# include "EventsQueue.hh"

namespace sdl {
  namespace core {
    namespace engine {

      class EventsDispatcher: public utils::CoreObject, public EventsQueue {
        public:

          explicit
          EventsDispatcher(const float& eventHandlingRate = 60.0f,
                          EngineShPtr engine = nullptr,
                          const bool exitOnEscape = true,
                          const std::string& name = std::string("event_dispatcher"));

          ~EventsDispatcher();

          void
          run();

          void
          stop();

          bool
          isRunning();

          void
          postEvent(EventShPtr event) override;

          /**
           * @brief - Performs the insertion of the input object as listeners of this queue.
           *          This allows the `listener` to receive all the events processed by this
           *          queue and to be scheduled regularly for events processing.
           *          Note that an error is raised if the listener is not valid or already
           *          existing in this queue.
           *          TODO: Add specific kind of listeners ? Like `WindowListener` for example.
           * @param listener - the object which should be added as a listener of this queue.
           */
          void
          addListener(EngineObject* listener) override;

          void
          removeListener(EngineObject* listener) override;

        private:

          using Events = std::vector<EventShPtr>;
          using Listeners = std::vector<EngineObject*>;

          void
          fetchSystemEvents();

          int
          consumeSystemEvents();

          int
          dispatchEventsFromQueue();

          void
          dispatchBroadcastEvents();

          void
          dispatchEvents(const Events& events);

          void
          dispatchEvent(const EventShPtr event);

          void
          trimAndPostBroadcastEvent(EventShPtr e);

          void
          trimAndPostDirectedEvent(EventShPtr e);

        private:

          float m_framerate;
          float m_frameDuration;
          bool m_exitOnEscape;

          EngineShPtr m_engine;

          bool m_eventsRunning;
          std::mutex m_executionLocker;
          std::shared_ptr<std::thread> m_executionThread;

          std::mutex m_eventsLocker;
          Events m_broadcastEvents;

          /**
           * @brief - This mutex is meant to protect the access to the `m_listeners` array. We need
           *          to make this mutex recursive so that whenever we dispatch some event to the
           *          array, some listeners might still be able to register new listeners (typically
           *          when creating new widgets) to this dispatcher.
           */
          std::recursive_mutex m_listenersLocker;

          /**
           * @brief - Holds all the registered listeners of this dispatcher. Note that the fact that
           *          this is implemented using a vector actually allows to provide some sort of
           *          orederings in events.
           *          Let's consider the following situation: a widget and its layout. The widget will
           *          presumably be created before the layout. So when the widget will be assigned an
           *          events queue, it will be registered as a listener of the queue. It will then
           *          proceed to registering its layout, which will thus be stored *after* the widget
           *          in this vector.
           *          This is important because when this dispatcher will process events, it will
           *          traverse the listeners *in order* and process events of each one sequentially.
           *          This way of doing guarantee that the events generated by the widget will be
           *          processed before the events generated by the layout. In this sense order matters.
           *          It is not necessarily a bad thing but it is important to keep that in mind so
           *          because it hides some potentially weird side effects.
           *          As an example if the layout is added before the widget, at some point the layout
           *          will process its geometry event, and do so with an invalid size because the
           *          event responsible for providing a valid size to the widget has not yet been
           *          processed.
           */
          Listeners m_listeners;
      };

      using EventsDispatcherShPtr = std::shared_ptr<EventsDispatcher>;
    }
  }
}

# include "EventsDispatcher.hxx"

#endif    /* EVENTS_DISPATCHER_HH */
